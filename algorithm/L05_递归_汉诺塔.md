
## 汉诺塔问题（Hanoi Tower Problem）
是一个经典的递归问题，源自一个传说，讲述的是一位僧侣需要将一堆不同大小的盘子从一根柱子移动到另一根柱子上，期间借助第三根柱子作为过渡，同时遵循以下规则：

盘子数量：通常假设初始时有多个盘子（传统上说是64个）堆叠在第一根柱子（称为源柱或A柱）上，盘子大小不一，大的在下，小的在上。

目标：游戏的目标是将所有盘子从源柱（A）移动到第三根柱子（称为目标柱或C柱），仍然保持原来从大到小的顺序。

![Hanoi Tower Problem](images/hanoi_01.jpg)

操作限制：

每次只能移动一个盘子。
盘子必须保持大盘在下，小盘在上的顺序，即任何时候都不能将一个较大的盘子放在较小的盘子之上。
只能使用中间的第二根柱子（称为辅助柱或B柱）作为过渡。

## 仅三个圆盘的图解：
![Hanoi Tower Problem solve](images/hanoi_02.png)

## 当那n个盘子时呢？

1. 我们将除了最下面的一个盘子以外的盘子看做一个整体，现在这个整体有n-1个盘子
2. 将n-1个盘子，放到B柱子(辅助柱),并且我们不管这n-1个盘子的具体挪动过程，我们只关心最后的结果，即n-1个盘子全部在B柱子上。
3. 将最下面一个盘子放到C柱子上。
4. 将n-1个盘子从B柱子移动到C柱子上，完成!

    

```python
def hanoi(n, source, target, auxiliary):  # 定义汉诺塔函数，n为盘子数量，source为起始柱A，target为目标柱C，auxiliary为辅助柱B。
    if n > 0:
        # 将n-1个盘子从源柱移动到辅助柱
        hanoi(n - 1, source, auxiliary, target)

        # 将最大的盘子从源柱移动到目标柱。
        print(f"从 {source} 到 {target} 移动一个盘子")  
        
        # 将n-1个盘子从辅助柱移动到目标柱
        hanoi(n - 1, auxiliary, target, source)
        
        # 递归调用，直到n为0，即所有盘子都移动到目标柱。
```

## 汉诺塔问题的时间复杂度

我们用T(n)表示n个盘子时，移动盘子的最少步数。

T(n)是多少次呢:
1. n-1个盘子从A到B,需要T(n-1)
2. 然后最大的盘子从A到C,需要1步
3. n-1个盘子从B到C,需要T(n-1)步。

所以T(n) = 2T(n-1) + 1, 这是一个递归式。
```python
T(n) = 2T(n-1) + 1
     = 2*(2T(n-2) + 1) + 1  
     = 2*(2*(2T(n-3) + 1) + 1 + 1) + 1 
     = 2^3*T(n-3) + ...
     = 2^k*T(n-k) + ...
     = 2^n + ...
     忽视低阶项后
     得到时间复杂度为O(2^n)
```
**指数爆炸**